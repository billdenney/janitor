#' Generate a comparison of data.frames (or similar objects) that indicates if
#' they will successfully bind together by rows.
#'
#' @details Due to the returned "column_name" column, no input data.frame may be
#'   named "column_name".
#'
#' @param ... data.frames or similar objects.  The values may optionally be
#'   named arguments; if named, the output column will be the name; if not
#'   named, the output columne will be the data.frame name (see examples
#'   section).
#' @param return Should a sumary of "all" columns be returned, only return
#'   "match"ing columns, or only "mismatch"ing columns.
#' @param bind_check What method of binding shoudl be used to determine matches?
#'   With "rbind", columns missing from a data.frame would be considered a
#'   mismatch; with "bind_rows" columns missing from a data.frame would be
#'   considered a match (as in \code{dplyr::bind_rows()}.
#' @return A data.frame with a column named "column_name" and other columns
#'   named after the input data.frames' column names, and then one column per
#'   data.frame (named after the input data.frame).  The rows within the
#'   data.frame-named columns are descriptions of the classes of the data within
#'   the columns (generated by \code{compare_df_types_class_detect}).
#' @examples
#' compare_df_types(data.frame(A=1), data.frame(B=2))
#' # user-defined names
#' compare_df_types(dfA=data.frame(A=1), dfB=data.frame(B=2))
#' @family Data frame type comparison
#' @export
compare_df_types <- function(..., return=c("all", "match", "mismatch"), bind_check=c("rbind", "bind_rows")) {
  return <- match.arg(return)
  bind_check <- match.arg(bind_check)
  direct_names <- names(list(...))
  indirect_names <-
    setdiff(
      as.character(match.call(expand.dots=TRUE)), 
      as.character(match.call(expand.dots=FALSE))
    )
  if (is.null(direct_names)) {
    final_names <- indirect_names
  } else {
    final_names <- direct_names
    mask_replace <- final_names %in% ""
    final_names[mask_replace] <- indirect_names[mask_replace]
  }
  if (any(final_names %in% "column_name")) {
    stop("None of the input ... arguments must be named `column_name`.")
  }
  args <- list(...)
  ret <- compare_df_types_df_maker(args[[1]], class_colname=final_names[1])
  for (idx in (1+seq_len(length(args) - 1))) {
    ret <-
      merge(
        ret,
        compare_df_types_df_maker(args[[idx]], class_colname=final_names[idx]),
        by="column_name",
        all=TRUE
      )
  }
  if (return == "all" | ncol(ret) == 2) {
    if (return != "all") {
      warning("Only one data.frame provided, so all its classes are provided.")
    }
    rownames(ret) <- NULL
    ret
  } else {
    # Is this the best way to check for all row values to be equal?
    bind_check_fun <-
      list(
        rbind=function(idx) {
          all(unlist(ret[idx,3:ncol(ret)]) %in% ret[idx,2])
        },
        bind_rows=function(idx) {
          all(
            unlist(ret[idx,3:ncol(ret)]) %in%
              c(NA_character_,
                na.omit(unlist(ret[idx,2:ncol(ret)]))[1])
          )
        }
      )
    mask_match <-
      sapply(
        X=seq_len(nrow(ret)),
        FUN=bind_check_fun[[bind_check]]
      )
    ret <-
      if (return == "match") {
        ret[mask_match,]
      } else if (return == "mismatch") {
        ret[!mask_match,]
      }
    rownames(ret) <- NULL
    ret
  }
}

#' This is the workhorse for making a data.frame description used by
#' compare_df_types
#' @param x The data.frame
#' @param class_colname The name for the column-name-defining column
#' @return A 2-column data.frame with the first column naming all the columns of
#'   \code{x} and the second column (named after the value in
#'   \code{class_colname}) defining the classes using
#'   \code{compare_df_types_class_detect()}.
#' @noRd
compare_df_types_df_maker <- function(x, class_colname="class") {
  if (class_colname == "column_name") {
    stop('`class_colname` cannot be "column_name"')
  }
  ret <-
    data.frame(
      column_name=names(x),
      X=sapply(X=x, FUN=compare_df_types_class_detect),
      stringsAsFactors=FALSE
    )
  names(ret)[2] <- class_colname
  ret
}

#' Will row binding succeed?
#' @inheritParams compare_df_types
#' @param verbose Print the mismatching columns if binding will fail.
#' @return \code{TRUE} if row binding will succeed or \code{FALSE} if it will
#'   fail.
#' @family Data frame type comparison
#' @examples
#' compare_df_types_success(data.frame(A=1), data.frame(A=2))
#' compare_df_types_success(data.frame(A=1), data.frame(B=2))
#' compare_df_types_success(data.frame(A=1), data.frame(B=2), verbose=FALSE)
#' compare_df_types_success(data.frame(A=1), data.frame(B=2), bind_check="bind_rows")
#' @export
compare_df_types_success <- function(..., return="mismatch", bind_check=c("rbind", "bind_rows"), verbose=TRUE) {
  return <- match.arg(return)
  bind_check <- match.arg(bind_check)
  ret <- compare_df_types(..., return=return, bind_check=bind_check)
  if (nrow(ret) & verbose) {
    print(ret)
  }
  nrow(ret) == 0
}

#' Describe the class(es) of an object
#'
#' @details An S3 generic method can be written for
#'   \code{compare_df_types_class_detect()} for other types that may need more
#'   definition than the default method.
#'
#' @param x The object to describe
#' @return A character scalar describing the class(es) of an object where if the
#'   scalar will match, columns in a data.frame (or similar object) should bind
#'   together without issue.
#' @family Data frame type comparison
#' @export
compare_df_types_class_detect <- function(x) {
  UseMethod("compare_df_types_class_detect")
}

#' @describeIn compare_df_types_class_detect Describe factors with their levels
#'   and if they are ordered.
#' @export
compare_df_types_class_detect.factor <- function(x) {
  all_classes <- class(x)
  all_levels <- levels(x)
  level_text <- sprintf("levels=c(%s)", paste('"', levels(x), '"', sep="", collapse=", "))
  factor_text <- sprintf("factor(%s)", level_text)
  mask_factor <- class(x) == "factor"
  all_classes[mask_factor] <- factor_text
  paste(all_classes, collapse=", ")
}

#' @describeIn compare_df_types_class_detect List all classes of an object.
#' @export
compare_df_types_class_detect.default <- function(x) {
  all_classes <- class(x)
  paste(all_classes, collapse=", ")
}
