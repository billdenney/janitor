#' Generate a comparison of data.frames (or similar objects) that indicates if
#' they will successfully bind together by rows.
#'
#' @details Due to the returned "column_name" column, no input data.frame may be
#'   named "column_name".
#'
#' @param ... data.frames or similar objects (such as tibbles), or lists of
#'   data.frames (or similar objects).  The values may optionally be named
#'   arguments; if named, the output column will be the name; if not named, the
#'   output columne will be the data.frame name (see examples section).
#' @param return Should a summary of "all" columns be returned, only return
#'   "match"ing columns, or only "mismatch"ing columns?
#' @param bind_check What method of binding should be used to determine matches?
#'   With "rbind", columns missing from a data.frame would be considered a
#'   mismatch (as in \code{base::rbind()}; with "bind_rows", columns missing
#'   from a data.frame would be considered a match (as in
#'   \code{dplyr::bind_rows()}.
#' @return A data.frame with a column named "column_name" with a value named
#'   after the input data.frames' column names, and then one column per
#'   data.frame (named after the input data.frame).  If more than one input
#'   would have the same column name, the column naming is from
#'   \code{base::merge()} and may differ from expected naming.  The rows within
#'   the data.frame-named columns are descriptions of the classes of the data
#'   within the columns (generated by \code{compare_df_types_class_detect}).
#' @examples
#' compare_df_types(data.frame(A=1), data.frame(B=2))
#' # user-defined names
#' compare_df_types(dfA=data.frame(A=1), dfB=data.frame(B=2))
#' # a combinatino of list and data.frame input
#' compare_df_types(listA=list(dfA=data.frame(A=1), dfB=data.frame(B=2)), data.frame(A=3))
#' @family Data frame type comparison
#' @export
compare_df_types <- function(..., return=c("all", "match", "mismatch"), bind_check=c("rbind", "bind_rows")) {
  # Input checking
  return <- match.arg(return)
  bind_check <- match.arg(bind_check)
  args <- list(...)
  mask_input_data_frame <- sapply(X=args, FUN=is.data.frame)
  mask_input_list <- sapply(X=args, FUN=is.list) & !mask_input_data_frame
  mask_input_other <- !(mask_input_data_frame | mask_input_list)
  if (any(mask_input_other)) {
    stop("Input given with `...` must be either a data.frame or a list of data.frames.")
  }
  bad_list_inputs <- numeric(0)
  for (idx in which(mask_input_list)) {
    bad_list_inputs <-
      c(
        bad_list_inputs,
        if (!all(sapply(X=args[[idx]], FUN=is.data.frame))) {
          idx
        } else {
          numeric(0)
        }
      )
  }
  if (length(bad_list_inputs)) {
    stop(
      "List inputs must be lists of data.frames.  List input ",
      if (length(bad_list_inputs) == 1) {
        paste("number", bad_list_inputs, "is not a list of data.frames.")
      } else if (length(bad_list_inputs) < 6) {
        paste("numbers", paste(bad_list_inputs, collapse=", "), "are not lists of data.frames.")
      } else {
        paste("numbers", paste(c(bad_list_inputs[1:5], "..."), collapse=", "), "are not lists of data.frames.")
      }
    )
  }

  # Generate and check column names
  direct_names <- names(args)
  indirect_names <-
    setdiff(
      as.character(match.call(expand.dots=TRUE)), 
      as.character(match.call(expand.dots=FALSE))
    )
  if (is.null(direct_names)) {
    final_names <- indirect_names
  } else {
    final_names <- direct_names
    mask_replace <- final_names %in% ""
    final_names[mask_replace] <- indirect_names[mask_replace]
  }
  final_names <- as.list(final_names)
  for (idx in which(mask_input_list)) {
    current_list_names <- names(args[[idx]])
    final_names[[idx]] <-
      if (is.null(current_list_names)) {
        paste(final_names[[idx]], seq_along(args[[idx]]), sep="_")
      } else if (any(mask_unnamed_list <- current_list_names %in% "")) {
        current_list_names[mask_unnamed_list] <-
          paste(
            final_names[[idx]][mask_unnamed_list],
            seq_len(sum(mask_unnamed_list)),
            sep="_"
          )
        current_list_names
      } else {
        current_list_names
      }
  }
  if (any(unlist(final_names) %in% "column_name")) {
    stop("None of the input ... argument names or list names may be `column_name`.")
  }
  ret <- compare_df_types_df_maker(args, class_colname=final_names)
  if (return == "all" | ncol(ret) == 2) {
    if (return != "all") {
      warning("Only one data.frame provided, so all its classes are provided.")
    }
    rownames(ret) <- NULL
    ret
  } else {
    # Is this the best way to check for all row values to be equal?
    bind_check_fun <-
      list(
        rbind=function(idx) {
          all(unlist(ret[idx,3:ncol(ret)]) %in% ret[idx,2])
        },
        bind_rows=function(idx) {
          all(
            unlist(ret[idx,3:ncol(ret)]) %in%
              c(NA_character_,
                na.omit(unlist(ret[idx,2:ncol(ret)]))[1])
          )
        }
      )
    mask_match <-
      sapply(
        X=seq_len(nrow(ret)),
        FUN=bind_check_fun[[bind_check]]
      )
    ret <-
      if (return == "match") {
        ret[mask_match,]
      } else if (return == "mismatch") {
        ret[!mask_match,]
      }
    rownames(ret) <- NULL
    ret
  }
}

#' This is the workhorse for making a data.frame description used by
#' compare_df_types
#' @param x The data.frame or list of data.frames
#' @param class_colname The name for the column-name-defining column
#' @return A 2-column data.frame with the first column naming all the columns of
#'   \code{x} and the second column (named after the value in
#'   \code{class_colname}) defining the classes using
#'   \code{compare_df_types_class_detect()}.
#' @noRd
compare_df_types_df_maker <- function(x, class_colname="class")
  UseMethod("compare_df_types_df_maker")

compare_df_types_df_maker.data.frame <- function(x, class_colname="class") {
  if (class_colname == "column_name") {
    stop('`class_colname` cannot be "column_name"')
  }
  if (ncol(x) == 0) {
    warning(class_colname, " has zero columns and will not appear in output.")
    ret <- data.frame(column_name=character(0), stringsAsFactors=FALSE)
  } else {
    ret <-
      data.frame(
        column_name=names(x),
        X=sapply(X=x, FUN=compare_df_types_class_detect),
        stringsAsFactors=FALSE
      )
    names(ret)[2] <- class_colname
  }
  ret
}

compare_df_types_df_maker.list <- function(x, class_colname="class") {
  if (length(class_colname) != length(x)) {
    stop("`x` and `class_colname` must be the same length.")
  } else if (any(class_colname == "column_name")) {
    stop('`class_colname` cannot be "column_name"')
  }
  ret <-
    lapply(
      X=seq_along(x),
      FUN=function(idx) {
        compare_df_types_df_maker(x=x[[idx]], class_colname=class_colname[[idx]])
      }
    )
  Reduce(f=function(x, y) {merge(x, y, by="column_name", all=TRUE)}, x=ret)
}

#' Will row binding succeed?
#' @inheritParams compare_df_types
#' @param verbose Print the mismatching columns if binding will fail.
#' @return \code{TRUE} if row binding will succeed or \code{FALSE} if it will
#'   fail.
#' @family Data frame type comparison
#' @examples
#' compare_df_types_success(data.frame(A=1), data.frame(A=2))
#' compare_df_types_success(data.frame(A=1), data.frame(B=2))
#' compare_df_types_success(data.frame(A=1), data.frame(B=2), verbose=FALSE)
#' compare_df_types_success(data.frame(A=1), data.frame(B=2), bind_check="bind_rows")
#' @export
compare_df_types_success <- function(..., return="mismatch", bind_check=c("rbind", "bind_rows"), verbose=TRUE) {
  return <- match.arg(return)
  bind_check <- match.arg(bind_check)
  ret <- compare_df_types(..., return=return, bind_check=bind_check)
  if (nrow(ret) & verbose) {
    print(ret)
  }
  nrow(ret) == 0
}

#' Describe the class(es) of an object
#'
#' @details An S3 generic method can be written for
#'   \code{compare_df_types_class_detect()} for other types that may need more
#'   definition than the default method.
#'
#' @param x The object to describe
#' @return A character scalar describing the class(es) of an object where if the
#'   scalar will match, columns in a data.frame (or similar object) should bind
#'   together without issue.
#' @family Data frame type comparison
#' @export
compare_df_types_class_detect <- function(x) {
  UseMethod("compare_df_types_class_detect")
}

#' @describeIn compare_df_types_class_detect Describe factors with their levels
#'   and if they are ordered.
#' @export
compare_df_types_class_detect.factor <- function(x) {
  all_classes <- class(x)
  all_levels <- levels(x)
  level_text <- sprintf("levels=c(%s)", paste('"', levels(x), '"', sep="", collapse=", "))
  factor_text <- sprintf("factor(%s)", level_text)
  mask_factor <- class(x) == "factor"
  all_classes[mask_factor] <- factor_text
  paste(all_classes, collapse=", ")
}

#' @describeIn compare_df_types_class_detect List all classes of an object.
#' @export
compare_df_types_class_detect.default <- function(x) {
  all_classes <- class(x)
  paste(all_classes, collapse=", ")
}
